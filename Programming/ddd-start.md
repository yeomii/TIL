# DDD Start

* 도메인 주도 설계 구현과 핵심 개념 익히기
* https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=84000742

---

# 02 아키텍처 개요

## 네 개의 영역
* 표현, 응용, 도메인, 인프라스트럭처
    * 아키텍처 설계시 전형적으로 사용하는 영역
* 표현 영역 - 사용자의 요청을 받아 응용영역에 전달하고 응용영역의 처리 결과를 다시 사용자에게 전달
* 응용 영역 - 시스템이 사용자에게 제공해야 할 기능을 구현
    * 기능을 구현하기 위에 도메인 영역의 도메인 모델을 사용
    * 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임
* 도메인 영역 - 도메인의 핵심 로직을 구현
* 인프라스트럭처 영역 - 논리적인 개념을 표현하기보다는 실제 구현을 다룸
    * 메시징 큐나 DB 와의 연동부분을 처리

## 계층 구조 아키텍처
* 네 개의 영역을 구성할 때 많이 사용하는 아키텍처
* 특성상 상위계층에서 하위계층으로의 의존만 존재하고 반대방향으로의 의존은 존재하지 않음
* 엄격하게는 상위계층은 바로 아래의 계층만 의존성을 가져야하지만 구현시 편리함 때문에 계층구조를 유연하게 가져가기도 함
    * 예) 도메인과 응용계층이 DB 연동을 위해 모두 인프라 모듈에 의존성을 갖는 경우
* 응용 모듈이 인프라 모듈에 직접 의존성을 갖는 경우 두 가지 문제점이 생길 수 있음
    * 응용 모듈만 테스트하기 어려움
    * 구현 방식을 변경하기 어려움 
        * 인프라 모듈 변경시 응용 모듈도 변경 작업이 필요할 수 있음

## DIP (Dependency Inversion Principle)
* 의존 역전 원칙

### 모듈의 구분
* 고수준 모듈 - 의미 있는 단일 기능을 제공하는 모듈
* 저수준 모듈 - 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능을 실제로 구현한 모듈

### DIP 적용
* 고수준 모듈이 저수준 모듈을 사용하면 앞서 살펴본 구현 변경과 테스트의 어려움이라는 두가지 문제점 발생
* DIP 는 이 문제 해결을 위해 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다.
* 적용 방법 - 저수준 모듈이 고수준 모듈에서 정의한 인터페이스를 구현하는 방식으로 적용
    * 구현 변경의 경우 - 저수준 구현 객체를 생성하는 부분의 코드만 변경하면 됨
    * 테스트의 경우 - 인터페이스의 대용 객체를 사용해서 테스트 가능 (mock)

* 의존 주입을 지원하는 스프링같은 프레임워크를 쓰면 설정코드를 수정해서 쉽게 구현체를 변경할 수 있다

### DIP 주의사항
* 잘못 적용하는 사례로, 단순히 저수준 모듈을 인터페이스와 구현 클래스로 분리할 수도 있음
* 저수준 모듈 관점에서 인터페이스를 도출하는 것이 아니라, 고수준 모듈 관점에서 하위 기능을 추상화 하여 인터페이스를 도출해야 한다

### DIP 와 아키텍쳐
* DIP 를 적용하면 응용 영역과 도메인 영역에 영향을 최소화하면서 구현체를 변경하거나 추가할 수 있다

## 도메인 영역의 주요 구성 요소
* 엔티티 
    * 고유의 식별자를 갖는 객체로 자신의 라이프 사이클을 갖는다
    * 도메인의 고유한 개념을 표현하고 이를 위한 데이터를 가지며 관련 기능을 함께 제공한다
* 밸류
    * 식별자를 갖자 않는 객체로 개념적으로 하나인 속성을 표현할 때 사용된다
* 애그리거트 (aggregate)
    * 관련된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것
* 리포지토리
    * 도메인 모델의 영속성을 처리
* 도메인 서비스
    * 특정 엔티티에 속하지 않은 도메인 로직 제공
    * 여러 앤티티와 밸류를 필요로 할 경우에만 도메인 서비스에서 로직 구현

### 엔티티와 밸류
* 도메인 모델의 엔티티와 DB 관계형 모델의 엔티티는 다름
    * 가장 큰 차이는 도메인 모델의 엔티티가 데이터와 함께 도메인 기능을 제공한다는 것

### 애그리거트
* 관련 객체를 하나로 묶은 군집
* 도메인 모델의 전체 구조를 이해하는 데에 도움이 됨
* 애그리거트는 군집에 속한 객체들을 관리하는 루트 엔티티를 갖는다
* 루트 엔티티는 애그리거트에 속해있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다
* 애그리거트 루트를 통해서 간접적으로 애그리거트 내의 다른 엔티티나 밸류 객체에 접근할 수 있다
* 자세한 내용은 3장에서

### 리포지토리
* 엔티티나 밸류는 요구사항에서 도출되는 반면, 리포지터리는 구현을 위한 도메인 모델이다
* 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다
* Order 애그리거트의 리포지터리 인터페이스 `OrderRepository` 와, 이를 구현한 `JPAOrderRepository` 클래스가 있을 떄
    * `OrderRepository` - 도메인 객체를 영속화하는 데 필요한 기능을 추상화한 것으로 고수준 모듈에 속함
    * `JPAOrderRepository` - 저수준 모듈로 인프라 모듈에 속함

* 응용 서비스와 리포지터리는 밀접한 연관이 있다
    * 응용 서비스에서 도메인 객체를 구하거나 저장할때 리포지터리 사용
    * 응용 서비스는 트랜잭션을 관리하는데, 트랜잭션 처리는 리포지터리 구현 기술에 영향을 받음
* 리포지터리의 가장 기본적인 메서드
    * 애그리거트를 저장하는 메서드
    * 애그리거트 루트 식별자로 애그리거트를 조회하는 메서드

## 요청 처리 흐름
* 응용 서비스는 트랜잭션을 관리한다

## 인프라스트럭처 개요
* 인프라스트럭처는 표현, 응용, 도메인 영역을 지원한다
* DIP 를 적용해서 도메인이나 응용이 인프라 모듈의 의존성을 가지지 않는 것이 좋지만, 그렇게 하는 것이 항상 좋은건 아니다
* `@Transaction` 이나 `@Entity`, `@Table` 과 같은 어노테이션을 응용 모듈이나 도메인 모델 클래스에 사용하는 것이 XML 매핑설정을 이용하는 것 보다 편리하다
* 표현 영역은 항상 인프라 영역과 쌍을 이룬다
    * 스프링 MVC 를 사용하면 프레임워크에 맞게 표현영역을 구현해야 한다

## 모듈 구성
* 도메인이 크면 하위 도메인으로 나누고 각 하위 도메인마다 표현, 응용, 도메인, 인프라 등과 같이 모듈별 별도 패키지를 구성한다
* 도메인 모듈은 도메인에 속한 애그리거트를 기준으로 다시 패키지를 구성한다
* 각 애그리거트 모델과 리포지터리는 같은 패키지에 위치시킨다
* 도메인이 복잡할경우는 도메인 모델과 도메인 서비스를 별도 패키지에 위치시킬 수도 있음
* 얼마나 모듈을 세분화해야 되는지에 대한 규칙은 없지만, 저자는 한 패키지에 가능하면 10개 미만의 타입 개수를 유지하려고 한다고 함








